package org.upLift.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.upLift.model.Recipient;
import org.upLift.model.RecipientTag;
import org.upLift.model.Tag;
import org.upLift.repositories.RecipientRepository;
import org.upLift.repositories.RecipientTagsRepository;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.TreeSet;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

@ExtendWith(MockitoExtension.class)
class FairnessServiceImplUnitTest {

	@Mock
	private RecipientRepository recipientRepository;

	@Mock
	private RecipientTagsRepository recipientTagsRepository;

	private FairnessServiceImpl fairnessService;

	@BeforeEach
	void setUp() {
		fairnessService = new FairnessServiceImpl(recipientTagsRepository, recipientRepository);
		fairnessService.setExcludeUnverifiedIncome(true);
		fairnessService.setNumberOfMatches(3);
	}

	@Nested
	@DisplayName("calculateOverallRecipientWeight")
	class CalculateOverallRecipientWeightTests {

		@Test
		void calculateOverallRecipientWeight_SelectedTags_NoDonation() {
			var recipientWithWeights = createRecipientWithTagWeights(new Recipient(), 1.3, 2.4);

			double result = fairnessService.calculateOverallRecipientWeight(recipientWithWeights, 1.8, 2.9);
			assertThat(result, is(closeTo(310.0, 1e-4)));
		}

		@Test
		void calculateOverallRecipientWeight_SelectedTags_OldDonation() {
			// Set last donation just over 1 year ago to max out donation weight
			var recipient = createRecipient(1, Instant.now().minus(366, ChronoUnit.DAYS));
			var recipientWithWeights = createRecipientWithTagWeights(recipient, 1.3, 2.4);

			double result = fairnessService.calculateOverallRecipientWeight(recipientWithWeights, 1.8, 2.9);
			assertThat(result, is(closeTo(310.0, 1e-4)));
		}

		@Test
		void calculateOverallRecipientWeight_SelectedTags_RecentDonation() {
			// Set last donation to less than half a year to check weight calculation
			var recipient = createRecipient(1, Instant.now().minus(150, ChronoUnit.DAYS));
			var recipientWithWeights = createRecipientWithTagWeights(recipient, 1.3, 2.4);

			double result = fairnessService.calculateOverallRecipientWeight(recipientWithWeights, 1.8, 2.9);
			assertThat(result, is(closeTo(203.92197, 1e-4)));
		}

		@Test
		void calculateOverallRecipientWeight_UnselectedTags_NoDonation() {
			var recipientWithWeights = createRecipientWithTagWeights(new Recipient(), 0, 2.4);

			double result = fairnessService.calculateOverallRecipientWeight(recipientWithWeights, 1.8, 2.9);
			assertThat(result, is(closeTo(5.3, 1e-4)));
		}

		@Test
		void calculateOverallRecipientWeight_UnselectedTags_OldDonation() {
			// Set last donation just over 1 year ago to max out donation weight
			var recipient = createRecipient(1, Instant.now().minus(366, ChronoUnit.DAYS));
			var recipientWithWeights = createRecipientWithTagWeights(recipient, 0, 2.4);

			double result = fairnessService.calculateOverallRecipientWeight(recipientWithWeights, 1.8, 2.9);
			assertThat(result, is(closeTo(5.3, 1e-4)));
		}

		@Test
		void calculateOverallRecipientWeight_UnselectedTags_RecentDonation() {
			// Set last donation to less than half a year to check weight calculation
			var recipient = createRecipient(1, Instant.now().minus(150, ChronoUnit.DAYS));
			var recipientWithWeights = createRecipientWithTagWeights(recipient, 0, 2.4);

			double result = fairnessService.calculateOverallRecipientWeight(recipientWithWeights, 1.8, 2.9);
			assertThat(result, is(closeTo(3.590965, 1e-4)));
		}

	}

	// Test method generated by JetBrains AI Assistant with a few manual tweaks
	@Test
	void getRecipientsFromTags() {

		// Create timestamps for donations
		Instant now = Instant.now();
		Instant recentDonation = now.minus(100, ChronoUnit.DAYS);
		Instant olderDonation = now.minus(300, ChronoUnit.DAYS);

		// Create recipients with verified income (within 365 days)
		var recipient1 = createRecipient(1, recentDonation);
		var recipient2 = createRecipient(2, olderDonation);
		var recipient3 = createRecipient(3, null);
		var recipient4 = createRecipient(4, recentDonation);
		recipient1.setIncomeLastVerified(now.minus(10, ChronoUnit.DAYS));
		recipient2.setIncomeLastVerified(now.minus(20, ChronoUnit.DAYS));
		recipient3.setIncomeLastVerified(now.minus(30, ChronoUnit.DAYS));
		recipient4.setIncomeLastVerified(now.minus(40, ChronoUnit.DAYS));

		// Create RecipientTags for each recipient
		var tag1 = createRecipientTag(recipient1, "tag1", 0.8, true);
		var tag2 = createRecipientTag(recipient2, "tag2", 0.7, true);
		var tag3 = createRecipientTag(recipient3, "tag1", 0.8, true);
		var tag4 = createRecipientTag(recipient4, "tag2", 0.7, false); // Only unselected
																		// tags

		// Mock repository responses
		Mockito.when(recipientTagsRepository.getRecipientTagsByTag_TagName("tag1")).thenReturn(List.of(tag1, tag3));
		Mockito.when(recipientTagsRepository.getRecipientTagsByTag_TagName("tag2")).thenReturn(List.of(tag2, tag4));

		// Call method under test
		List<Recipient> result = fairnessService.getRecipientsFromTags(List.of("tag1", "tag2"));

		// Verify results
		assertThat(result, hasSize(3));

		// Highest weight with null donation timestamp
		assertThat(result.get(0), is(recipient3));
		// Lower weight than recipient1, but has older donation
		assertThat(result.get(1), is(recipient2));
		// Lower weight due to more recent donation
		assertThat(result.get(2), is(recipient1));

		// Recipient 4 should not be included as it only had unselected tags and weight
		// was too low
		assertThat(result, not(hasItem(recipient4)));
	}

	@Test
	void buildRecipientMap() {
		// Recipient with income verified just inside deadline
		var recipient1 = createRecipient(1, Instant.now().minus(366, ChronoUnit.DAYS));
		recipient1.setIncomeLastVerified(Instant.now().minus(364, ChronoUnit.DAYS));
		// Recipient with expired income verification
		var recipient2 = createRecipient(2, Instant.now().minus(150, ChronoUnit.DAYS));
		recipient2.setIncomeLastVerified(Instant.now().minus(366, ChronoUnit.DAYS));
		// Recipient with income verified inside deadline
		var recipient3 = createRecipient(3, null);
		recipient3.setIncomeLastVerified(Instant.now().minus(363, ChronoUnit.DAYS));
		// Recipient with no income verification
		var recipient4 = createRecipient(4, null);
		// Recipient with income verified inside deadline
		var recipient5 = createRecipient(5, null);
		recipient5.setIncomeLastVerified(Instant.now().minus(2, ChronoUnit.DAYS));

		var tag1A = createRecipientTag(recipient1, "tag1", 0.5, true);
		var tag1B = createRecipientTag(recipient1, "tag2", 0.3, true);
		var tag1C = createRecipientTag(recipient1, "tag3", 0.6, true);
		var tag1D = createRecipientTag(recipient1, "tag4", 0.8, false);
		recipient1.setTags(new TreeSet<>(List.of(tag1A, tag1B, tag1C, tag1D)));

		var tag2A = createRecipientTag(recipient2, "tag1", 0.5, true);
		var tag2B = createRecipientTag(recipient2, "tag2", 0.3, false);
		var tag2C = createRecipientTag(recipient2, "tag3", 0.6, false);
		var tag2D = createRecipientTag(recipient2, "tag4", 0.8, true);
		recipient2.setTags(new TreeSet<>(List.of(tag2A, tag2B, tag2C, tag2D)));

		var tag3A = createRecipientTag(recipient3, "tag1", 0.5, false);
		var tag3B = createRecipientTag(recipient3, "tag2", 0.3, false);
		var tag3C = createRecipientTag(recipient3, "tag3", 0.6, false);
		var tag3D = createRecipientTag(recipient3, "tag4", 0.8, false);
		recipient3.setTags(new TreeSet<>(List.of(tag3A, tag3B, tag3C, tag3D)));

		var tag4A = createRecipientTag(recipient3, "tag1", 0.5, false);
		var tag4B = createRecipientTag(recipient3, "tag2", 0.3, false);
		var tag4C = createRecipientTag(recipient3, "tag3", 0.6, false);
		recipient4.setTags(new TreeSet<>(List.of(tag4A, tag4B, tag4C)));

		var tag5A = createRecipientTag(recipient2, "tag1", 0.5, true);
		var tag5B = createRecipientTag(recipient2, "tag2", 0.3, false);
		var tag5C = createRecipientTag(recipient2, "tag3", 0.6, false);
		var tag5D = createRecipientTag(recipient2, "tag4", 0.8, true);
		recipient5.setTags(new TreeSet<>(List.of(tag5A, tag5B, tag5C, tag5D)));

		Mockito.when(recipientTagsRepository.getRecipientTagsByTag_TagName("tag1"))
			.thenReturn(List.of(tag1A, tag2A, tag3A, tag4A, tag5A));
		Mockito.when(recipientTagsRepository.getRecipientTagsByTag_TagName("tag2"))
			.thenReturn(List.of(tag1B, tag2B, tag3B, tag4B, tag5B));
		Mockito.when(recipientTagsRepository.getRecipientTagsByTag_TagName("tag3"))
			.thenReturn(List.of(tag1C, tag2C, tag3C, tag4C, tag5C));
		Mockito.when(recipientTagsRepository.getRecipientTagsByTag_TagName("tag4"))
			.thenReturn(List.of(tag1D, tag2D, tag3D, tag5D));

		var result = fairnessService.buildRecipientMap(List.of("tag1", "tag2", "tag3", "tag4"));
		assertThat(result, allOf(hasKey(1), hasKey(3), hasKey(5)));
		assertThat(result, is(aMapWithSize(3)));

		var result1 = result.get(1);
		assertThat(result1.getRecipient(), is(sameInstance(recipient1)));
		assertThat(result1.getSelectedTagWeight(), is(closeTo(1.4, 1e-4)));
		assertThat(result1.getUnselectedTagWeight(), is(closeTo(0.8, 1e-4)));

		var result3 = result.get(3);
		assertThat(result3.getRecipient(), is(sameInstance(recipient3)));
		assertThat(result3.getSelectedTagWeight(), is(closeTo(0, 1e-4)));
		assertThat(result3.getUnselectedTagWeight(), is(closeTo(2.2, 1e-4)));

		var result5 = result.get(5);
		assertThat(result5.getRecipient(), is(sameInstance(recipient5)));
		assertThat(result5.getSelectedTagWeight(), is(closeTo(1.3, 1e-4)));
		assertThat(result5.getUnselectedTagWeight(), is(closeTo(0.9, 1e-4)));
	}

	@Test
	void buildWeightedRecipients() {
		var recipient1 = createRecipient(1, Instant.now().minus(366, ChronoUnit.DAYS));
		var recipientWithWeights1 = createRecipientWithTagWeights(recipient1, 1.3, 2.4);

		var recipient2 = createRecipient(2, Instant.now().minus(150, ChronoUnit.DAYS));
		var recipientWithWeights2 = createRecipientWithTagWeights(recipient2, 0.0, 3.6);

		var recipient3 = createRecipient(3, null);
		var recipientWithWeights3 = createRecipientWithTagWeights(recipient3, 2.7, 0.0);

		var recipient4 = createRecipient(4, Instant.now().minus(200, ChronoUnit.DAYS));
		var recipientWithWeights4 = createRecipientWithTagWeights(recipient4, 2.9, 4.1);

		var result = fairnessService.buildWeightedRecipients(
				List.of(recipientWithWeights1, recipientWithWeights2, recipientWithWeights3, recipientWithWeights4));
		assertThat(result, hasSize(4));

		var weightedRecipient1 = result.getFirst();
		assertThat(weightedRecipient1.getId(), is(1));
		assertThat(weightedRecipient1.getLastDonationTimestamp(), is(recipient1.getLastDonationTimestamp()));
		assertThat(weightedRecipient1.weight(), is(closeTo(420.0, 1e-4)));

		var weightedRecipient2 = result.get(1);
		assertThat(weightedRecipient2.getId(), is(2));
		assertThat(weightedRecipient2.getLastDonationTimestamp(), is(recipient2.getLastDonationTimestamp()));
		assertThat(weightedRecipient2.weight(), is(closeTo(5.283778, 1e-4)));

		var weightedRecipient3 = result.get(2);
		assertThat(weightedRecipient3.getId(), is(3));
		assertThat(weightedRecipient3.getLastDonationTimestamp(), is(nullValue()));
		assertThat(weightedRecipient3.weight(), is(closeTo(560.0, 1e-4)));

		var weightedRecipient4 = result.get(3);
		assertThat(weightedRecipient4.getId(), is(4));
		assertThat(weightedRecipient4.getLastDonationTimestamp(), is(recipient4.getLastDonationTimestamp()));
		assertThat(weightedRecipient4.weight(), is(closeTo(448.795346, 1e-4)));
	}

	// Test method created by JetBrains AI Assistant with a few manual tweaks
	@Test
	void sortWeightedRecipients() {
		// Create test timestamps
		Instant timestamp1 = Instant.now().minus(100, ChronoUnit.DAYS);
		Instant timestamp2 = Instant.now().minus(200, ChronoUnit.DAYS);

		// Create six recipients with different IDs
		var recipient1 = createRecipient(1, null); // No donation timestamp
		var recipient2 = createRecipient(2, null); // No donation timestamp
		var recipient3 = createRecipient(3, timestamp1); // Same timestamp as recipient4
		var recipient4 = createRecipient(4, timestamp1); // Same timestamp as recipient3
		var recipient5 = createRecipient(5, timestamp2); // Different timestamp
		var recipient6 = createRecipient(6, Instant.now()); // Highest weight, latest
															// timestamp and ID

		// Create list of weighted recipients - five with same weight (100.0), one with
		// different weight (200.0)
		List<FairnessServiceImpl.WeightedRecipient> weightedRecipients = Arrays.asList(
				new FairnessServiceImpl.WeightedRecipient(recipient4, 100.0),
				new FairnessServiceImpl.WeightedRecipient(recipient2, 100.0),
				new FairnessServiceImpl.WeightedRecipient(recipient6, 200.0),
				new FairnessServiceImpl.WeightedRecipient(recipient1, 100.0),
				new FairnessServiceImpl.WeightedRecipient(recipient5, 100.0),
				new FairnessServiceImpl.WeightedRecipient(recipient3, 100.0));

		// Sort the recipients
		fairnessService.sortWeightedRecipients(weightedRecipients);

		// Verify the order:
		// 1. Recipient6 should be first (highest weight)
		// 2. Recipients with no timestamp (1, 2) should come next (same weight, null
		// timestamp first)
		// 3. Then recipients with timestamps ordered by timestamp, then ID
		// Highest weight
		assertThat(weightedRecipients.get(0).recipient().getId(), is(6));
		// Null timestamp, lower ID
		assertThat(weightedRecipients.get(1).recipient().getId(), is(1));
		// Null timestamp, higher ID
		assertThat(weightedRecipients.get(2).recipient().getId(), is(2));
		// Earlier timestamp2
		assertThat(weightedRecipients.get(3).recipient().getId(), is(5));
		// Later timestamp1, lower ID
		assertThat(weightedRecipients.get(4).recipient().getId(), is(3));
		// Same timestamp1, higher ID
		assertThat(weightedRecipients.get(5).recipient().getId(), is(4));
	}

	@Test
	void resizeRecipients_TooFewRecipients() {
		Instant now = Instant.now();
		// Fill in existing list with only 1 recipient
		var recipient1 = createRecipient(1, null);
		recipient1.setIncomeLastVerified(now.minus(1, ChronoUnit.DAYS));

		// Mock a couple of recipients to return when adding more, only one of which is
		// valid
		// to check that it stops adding when the end of the list is reached
		var recipient2 = createRecipient(2, null);
		recipient2.setIncomeLastVerified(now.minus(1, ChronoUnit.DAYS));
		var recipient3 = createRecipient(3, null);
		Mockito.when(recipientRepository.getRecipientsByLastDonationTimestamp(Mockito.any(Instant.class)))
			.thenReturn(List.of(recipient3, recipient2, recipient1));

		var result = fairnessService.resizeRecipients(new ArrayList<>(List.of(recipient1)));
		assertThat(result, hasSize(2));
		assertThat(result.get(0), is(recipient1));
		assertThat(result.get(1), is(recipient2));
	}

	// Test method generated by JetBrains AI Assistant with some manual tweaks
	@Test
	void resizeRecipients_TooManyRecipients() {
		// Create initial list with 4 recipients
		var recipient1 = createRecipient(1, null);
		var recipient2 = createRecipient(2, null);
		var recipient3 = createRecipient(3, null);
		var recipient4 = createRecipient(4, null);

		List<Recipient> recipients = new ArrayList<>(List.of(recipient1, recipient2, recipient3, recipient4));
		var result = fairnessService.resizeRecipients(recipients);

		// Check that only the first 3 recipients are returned
		assertThat(result, hasSize(3));
		assertThat(result, contains(recipient1, recipient2, recipient3));
		assertThat(result, not(hasItem(recipient4)));
	}

	// Test method generated by JetBrains AI Assistant with some manual tweaks
	@Test
	void resizeRecipients_CorrectNumberOfRecipients() {
		// Create initial list with desired number of recipients
		var recipient1 = createRecipient(1, null);
		var recipient2 = createRecipient(2, null);
		var recipient3 = createRecipient(3, null);

		List<Recipient> recipients = new ArrayList<>(List.of(recipient1, recipient2, recipient3));
		var result = fairnessService.resizeRecipients(recipients);

		// Check that only the first 3 recipients are returned
		assertThat(result, hasSize(3));
		assertThat(result, contains(recipient1, recipient2, recipient3));
		assertThat(result, is(sameInstance(recipients)));
	}

	// Method created by JetBrains AI Assistant with a few manual tweaks
	@Test
	void addUnmatchedRecipients() {
		// Create timestamps for income verification
		Instant now = Instant.now();
		Instant verifiedRecent = now.minus(364, ChronoUnit.DAYS);
		Instant verifiedExpired = now.minus(366, ChronoUnit.DAYS);
		Instant verifiedVeryRecent1 = now.minus(100, ChronoUnit.DAYS);
		Instant verifiedVeryRecent2 = now.minus(150, ChronoUnit.DAYS);

		// Create initial recipient (already in the list)
		var existingRecipient = createRecipient(1, null);
		existingRecipient.setIncomeLastVerified(verifiedRecent);
		List<Recipient> recipients = new ArrayList<>(List.of(existingRecipient));

		// Create recipients to be returned by repository
		var recipient2 = createRecipient(2, null);
		recipient2.setIncomeLastVerified(verifiedRecent);

		var recipient3 = createRecipient(3, null);
		recipient3.setIncomeLastVerified(verifiedExpired);

		var recipient5 = createRecipient(5, null);
		recipient5.setIncomeLastVerified(verifiedVeryRecent1);

		var recipient6 = createRecipient(6, null);
		recipient6.setIncomeLastVerified(verifiedVeryRecent2);

		// Mock repository response
		Mockito.when(recipientRepository.getRecipientsByLastDonationTimestamp(Mockito.any(Instant.class)))
			.thenReturn(List.of(recipient2, recipient3, existingRecipient, recipient5, recipient6));

		// Call method under test
		fairnessService.addUnmatchedRecipients(recipients);

		// Verify results
		// Should have only 3 recipients total, meeting the desired number of matches
		// (original + first two with valid income verification)
		// Recipient3 should be excluded (expired verification)
		// Existing recipient should only be present once (no duplicates)
		// Recipient6 should be excluded (not needed)
		assertThat(recipients, hasSize(3));
		assertThat(recipients, containsInAnyOrder(existingRecipient, // ID 1
				recipient2, // ID 2
				recipient5 // ID 5
		));
	}

	FairnessService.RecipientWithMatchedTagWeights createRecipientWithTagWeights(Recipient recipient,
			double selectedTagWeight, double unselectedTagWeight) {
		var recipientWithWeights = new FairnessService.RecipientWithMatchedTagWeights(recipient);
		recipientWithWeights.setSelectedTagWeight(selectedTagWeight);
		recipientWithWeights.setUnselectedTagWeight(unselectedTagWeight);
		return recipientWithWeights;
	}

	RecipientTag createRecipientTag(Recipient recipient, String tag, double weight, boolean selected) {
		var recipientTag = new RecipientTag().weight(weight).selected(selected);
		recipientTag.setRecipient(recipient);
		recipientTag.setTag(new Tag().tagName(tag));
		return recipientTag;
	}

	Recipient createRecipient(int id, Instant lastDonationTimestamp) {
		var recipient = new Recipient().id(id);
		recipient.setLastDonationTimestamp(lastDonationTimestamp);
		return recipient;
	}

}
